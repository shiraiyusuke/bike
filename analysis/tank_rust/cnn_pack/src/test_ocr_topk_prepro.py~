#!/usr/bin/env python
"""
classify.py is an out-of-the-box image classifer callable from the command line.
By default it configures and runs the Caffe reference ImageNet model.
"""
import numpy as np
import pandas as pd
import os
import sys
import argparse
import glob
import time

import caffe
from PIL import Image


######## params ########
K = 10
input_dir = "../../arg_data/noal_test_imgs"
output_file = "./result.txt"
image_dims = (56, 56)
crop_dims = (48, 48)
model_def = "./ocr_deploy.prototxt"
pretrained_model = "./arg_ocr_iter_160000.caffemodel"
mean_file = "./mean_noal_56_56_0910_nost.npy"


center_only = True
input_scale = 0.00390625
gpu = True
rm_white = True
alpha = 1.8
########################


# Make classifier.
tmp_x = int((image_dims[0] - crop_dims[0])/2.0)
tmp_y = int((image_dims[1] - crop_dims[1])/2.0)
crop_rect = (tmp_x, image_dims[0]-tmp_x, tmp_y, image_dims[1]-tmp_y)
print crop_rect
classifier = caffe.Classifier(model_def, pretrained_model,
                              image_dims=image_dims,gpu=gpu,
                              input_scale=input_scale, 
                              mean=np.load(mean_file)[:,crop_rect[0]:crop_rect[1],crop_rect[2]:crop_rect[3]])

#lst
pathes = glob.glob(input_dir + "/*")

#fcn : load img and remove white 
def load_prepro( img_path , al = 1.5):
    img = Image.open(img_path).convert('L')
    img_arr = np.asarray(img,dtype=np.float32)
    if img.size[0]*al < img.size[1]:
        tmp = 255 - img_arr
        sums = tmp.sum(axis = 1)
        idx = np.arange(len(sums))
        idx_use = idx[sums > 0]
        if len(idx_use) < img.size[0]:
            tmp = img.size[0] - len(idx_use)
            tmp_idx = np.random.choice(idx[sums==0],tmp)
            idx_use = np.hstack((idx_use, tmp_idx))
            idx_use.sort()
        img_arr = img_arr[idx_use, :]
    return img_arr[:, :, np.newaxis]

# load
if rm_white:
    inputs = [load_prepro(im_f, al=alpha) for im_f in pathes]
else:
    inputs = [np.asarray(Image.open(im_f).convert("L"), dtype=np.float32)[:,:,np.newaxis] for im_f in pathes]

# Classify
print("Classifying %d inputs." % len(inputs))
start = time.time()
predictions = classifier.predict(inputs, not center_only)
print("Done in %.2f s." % (time.time() - start))

# top-K predict
top_k_args = np.argsort(-predictions, axis=1)[:,:K]
tmp = [str(i) for i in range(K)]
data = pd.DataFrame(top_k_args)
data.columns = tmp
data["path"] = pathes
data.to_csv(output_file, index=False)


